---
layout: post
title: 初次接触java中的反射机制
thread: 22
categories: 记录
tags: java 
---

JAVA语言中的反射机制：

- 在Java 运行环境中，对于任意一个类，我们都可以获取类的信息，以及类的属性和方法
   
  JAVA反射机制主要提供了以下功能：
      1.在运行时判断任意一个对象所属的类
      2.在运行时构造任意一个类的对象
      3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）
      4.在运行时调用任意一个对象的方法（*****注意：前提都是在运行时，而不是在编译时）
  Java 反射相关的API简介：
      位于java。lang。reflect包中
        --Class类：代表一个类
        --Filed类：代表类的成员变量
        --Method类：代表类的方法
        --Constructor类：代表类的构造方法
        --Array类：提供了动态创建数组，以及访问数组的元素的静态方法。该类中的所有方法都是静态方法

----Class类
     在 java 的Object类中的申明了数个应该在所有的java类中被改写的methods：
hashCode(), equals(),clone(),toString(),getClass()等，其中的getClass()返回yige
Class 类型的对象。
     Class类十分的特殊，它和一般的类一样继承自Object，其实体用以表达java程序运行
时的 class和 interface，也用来表达 enum，array，primitive，Java Types 以及关键字void
，当加载一个类，或者当加载器（class loader）的defineClass（）被JVM调用，便产生一个Class
对象，
     Class是Reflection起源，针对任何你想探勘的class（类），唯有现为他产生一个Class
的对象，接下来才能经由后者唤起为数十多个的反射API。

     Java允许我们从多种途径为一个类class生成对应的Class对象。
          --运用 getClass（）：Object类中的方法，每个类都拥有此方法 
                                String str="abc";
                                Class cl=str.getClass();

         --运用 Class。getSuperclass（）：Class类中的方法，返回该Class的父类的Class
         --运用 Class。forName（）静态方法：
         --运用 ,Class：类名.class
         --运用primitive wrapper classes的TYPE语法： 基本类型包装类的TYPE，如：Integer.TYPE
                      注意：TYPE的使用，只适合原生（基本）数据类型
----运行时生成instance
     想生成对象的实体，在反射动态机制中有两种方法，一个针对无变量的构造方法，一个针对带参数的
构造方法，，如果想调用带参数的构造方法，就比较的麻烦，不能直接调用Class类中的newInstance（）
，而是调用Constructor类中newInstance（）方法，首先准备一个Class[]作为Constructor的参数类型。
然后调用该Class对象的getConstructor（）方法获得一个专属的Constructor的对象，最后再准备一个
Object[]作为Constructor对象昂的newInstance（）方法的实参。
      在这里需要说明的是 只有两个类拥有newInstance（）方法，分别是Class类和Constructor类
Class类中的newInstance（）方法是不带参数的，而Constructro类中的newInstance（）方法是带参数的
需要提供必要的参数。
    例:
      Class c=Class.forName("DynTest");
      Class[] ptype=new Class[]{double.class,int.class}；
      Constructor ctor=c.getConstructor(ptypr);
      Object[] obj=new Object[]{new Double(3.1415),new Integer(123)};
      Object object=ctor.newInstance(obj);
      System.out.println(object);
----运行时调用Method
    这个动作首先准备一个Class[]{}作为getMethod（String name，Class[]）方法的参数类型，接下来准备一个
Obeject[]放置自变量，然后调用Method对象的invoke（Object obj，Object[]）方法。
     注意，在这里调用
----运行时调用Field内容
    变更Field不需要参数和自变量，首先调用Class的getField（）并指定field名称，获得特定的Field对象后
便可以直接调用Field的 get（Object obj）和set(Object obj,Object value)方法


- 参考链接：<a href="http://hejianjie.iteye.com/blog/136205" target="_blank">hejianjie</a>
   
- 首次编辑于：2014-03-03

