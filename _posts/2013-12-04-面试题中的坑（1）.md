---
layout: post
title: 面试题中的坑（1）
thread: 11
categories: 记录
tags: java
---

  今天我把我遇到的几个坑罗列出来，并加以分析下 
  
  - 后自增的问题
  - ‘+’ 运算符的重载
  
  ###后自增

  面试题会考什么？ 形如 a = b++; 这种么？ 我想你基本是不会碰到的，那面试题都怎么考，让我们来看一个例子。
        
         int a = 1;
         a = a ++;
         System.out.println(a);
    
 答案是什么，你答对了么？
    
 java 中得到的答案跟我们在C 中得到的答案是不一样的。java解析器在生成class文件是不一致的
    
 下面用两个例子详细解释
    
  Demo_01.java
    
        public class Demo_01 {
           public static void main(String[] args) {
               int i = 1;
               i = ++i;
               System.out.println(i);
           }
        }
        //结果为2
  Demo_02.java
        public class Demo_02 {
           public static void main(String[] args) {
             int i = 1;
             i = i++;
             System.out.println(i);
           }
        }
        //结果为1
        
   我们反编译其class的文件
     
   使用javap -v Demo_01 查看内容（代码片段）：
   
        public static void main(java.lang.String[]);
           flags: ACC_PUBLIC, ACC_STATIC
        Code:
         stack=2, locals=2, args_size=1
          0: iconst_1      //将1推送到栈顶
          1: istore_1      //将栈顶的内容赋值给第二个变量i，注意此时栈顶的内容是:1
          2: iinc     1, 1 //执行加一操作
          5: iload_1       //将变量i的内容推送到栈顶
          6: istore_1      //将栈顶的内容保存到变量i
          7: getstatic #16  // Field java/lang/System.out:Ljava/io/PrintStream;
         10: iload_1       
         11: invokevirtual #22    // Method java/io/PrintStream.println:(I)V
         14: return    
       
  查看 Demo_02 的部分内容：
  
        public static void main(java.lang.String[]);
         flags: ACC_PUBLIC, ACC_STATIC
        Code:
         stack=2, locals=2, args_size=1
          0: iconst_1      
          1: istore_1      
          2: iload_1       //将变量i的内容推送到栈顶，不知道为什么这么生成字节码！注意此时栈顶的内容是：1
          3: iinc    1, 1  //执行加一操作       
          6: istore_1      //将栈顶的内容保存到变量i
          7: getstatic  #16  // Field java/lang/System.out:Ljava/io/PrintStream;
         10: iload_1       
         11: invokevirtual #22    // Method java/io/PrintStream.println:(I)V
         14: return 
         
      从上我们可以看出，后自增是没有将自增后的内容再推送到栈顶的，即先变为2后被重置为1.
     所以以后我们可以这么理解后自增表达式： 
     
     1. 先取变量的值作为整个后自增表达式的值
     2. 执行自增运算
     3. 将整个表达式的值再赋值给其他变量
   
####命令说明
   
   - iconst_1   将int型1推送至栈顶 
   - istore_1   将栈顶int型数值存入第二个本地变量 
   - iload_1    将第二个int型本地变量推送至栈顶（正是因为少了这个操作，才出现以上问题） 
   - iinc       将指定int型变量增加指定值（i++, i--, i+=2）  
   
### + 运算符的重载
    
 同上一样，你能一眼做正确的，它也不会考，考的都是你容易掉坑里的那种题，形如：
    
        System.out.println('1' + 2 + "ABC" + '3' ) ; 
        
        //结果为  51ABC3  
        //'1'字符的ASCII码为49 
    
    如有错误，请留言指正。
