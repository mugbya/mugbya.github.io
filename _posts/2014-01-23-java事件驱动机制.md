---
layout: post
title: 初次接触java的事件驱动机制
thread: 18
categories: 记录
tags: java
---

   >引言：说是初次，只是想表示自己接触的太少，或者之前有用过，但没真正了解过。就如界面的按键响应来说，都是说什么实现相应的监听器接口就能捕获到相应的事件，从而进行相应的响应处理。而在最近参考高人的代码时，别人用到了事件驱动机制，所以这里我把我了解跟所做的笔记记录如下：(描述部分参考网上)

###事件驱动相关的概念

 - 事件源：负责产生事件并接受事件的源体
 - 事件类：定义事件的特征；
 - 监听器接口：定义监听器应该实现的功能；
 - 监听器：实现监听器接口，监听事件的发生并作出响应；

####事件类  

- 所有的事件类必须继承Java事件基类，即java.util.EventObject；EventObject(Object source)是EventObject唯一的构造方法，这意味着所有事件必须在实例化时就指定事件源；EventObject类提供了getSource()方法来获取事件源
- 定义了事件类后，产生一个事件，就是生成事件类的一个实例。
- 除了事件源，复杂的事件类代码可以含有其他属性、方法，包含更多的信息，如事件的名称、事件发生的时间、事件所属类别以及事件的描述等等

####监听器接口   

- 监听器接口定义了一个类要成为监听器必须具备的功能。所有的监听器接口也都必须继承监听器接口基类java.util.EventListener；EventListener本身没有定义任何方法，它只是一个标志接口，用来表明所有继承自EventListener的接口属于监听器接口。
- 监听器接口定义了监听器必须实现的方法。可以在监听器接口中定义任意多的事件处理方法，取决于应用所需，事件处理方法以事件对象作为入口参数，包含对事件进行处理的代码，方法名称任意，如processEvent或者handleEvent之类。

####监听器   

- 监听器是监听器接口的实现者，提供监听器接口中定义的所有方法的实现代码。简单情形下，一个监听器只监听一种类型的事件，即实现一种监听器接口。复杂的监听器可以实现多种监听器接口，监听多种类型的事件。
- 在事件处理方法代码中，监听器可以从入口参数中获得事件对象，并通过该对象获得所需的信息，例如事件源、事件发生时间等等。事件源是一定可以从事件对象中获得的，因为事件基类EventObject提供了getSource()方法，除此以外，能从事件对象中获得的信息，取决于事件类的定义。

####事件源   

作为事件源的类，必需满足以下条件：
- 事件源必须在内部维护一个已注册监听器的列表。当某监听器注册时，该监听器被添加到列表中，而监听器注销时，则从列表中删除；
- 事件源必须提供注册方法，以允许监听器注册为事件的接收者；
- 事件源必须提供注销方法，以允许监听器注销，停止对事件的接收；
- 事件源必须能够实例化事件类，即产生事件对象；


在Java的事件驱动模式中，事件源是最复杂的。多数情况下，程序员只需编写监听器的代码，而并不需要编写事件源代码
   
 >下面写下整个测试模型（需注意：本测试模拟awt中的timer(不完全模拟)，不含监听撤销撤销，对事件类未作细化；未做其相应的继承）  
 
- 事件类  （占且不做任何处理）
 
        package mugbya.timer;
        /**
         * @author mugbya
         * 
         * @version 2014年1月23日
         */
        public class TimerEventArg {    
        }

- 监听器接口
 
        package mugbya.timer;
        /**
         * 定时器的监听框架
         * 
         * @author mugbya
         * 
         * @version 2014年1月22日
         * 
         */
        public interface TimerActionListener {
            /**
             * 处理事件
             * @param sender 事件源对象
             * @param arg  事件类对象
             */
            void handleEvent(MyTimer sender, TimerEventArg arg);
        }

- 监听器 （当接口中的方法不多时可不实现，但在实际中，我们都需实现） 
 
        package mugbya.timer;
        /**
         * 计时器监听事件的空实现
         * 
         * @author mugbya
         * 
         * @version 2014年1月22日
         * 
         */
        public class TimerActionAdpadter implements TimerActionListener {
            @Override
            public void handleEvent(MyTimer sender, TimerEventArg arg) {
                
            }
        } 

- 事件源 
 
        package mugbya.timer;
        
        import java.util.ArrayList;
        import java.util.List;
        import java.util.Vector;
        
        /**
         * 定义 事件源
         * 
         * @author mugbya
         * 
         * @version 2014年1月22日
         * 
         */
        public class MyTimer {
        
            // 计时器的监听事件列表
            public List<TimerActionListener> listenersList = new ArrayList<TimerActionListener>();
            
            /**
             * 让计时器跑起来
             */
            public void start() {
                while (true) {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    actionStart(new TimerEventArg());
                }
            }
        
            /**
             * 引发服务事件启动
             * @param arg
             */
            public void actionStart(TimerEventArg arg) {
                for (TimerActionListener listener : listenersList) {
                    listener.handleEvent(this, arg);
                }
            }
        
            public void addActionListner(TimerActionListener listener) {
                // TODO 向服务事件列表中添加事件监听器
                if (listenersList == null) {
                    listenersList = new Vector<TimerActionListener>();
                }
                listenersList.add(listener);
            }
        
            void removeActionListener(TimerActionListener listener) {
                // TODO 从服务事件列表中删除事件监听器
                if (listenersList != null) {
                    listenersList.remove(listener);
                }
                if (listenersList.size() <= 0) {
                    listenersList = null;
                }
            }
        }


- 最后用一个Test进行相应测试 （这里分包了，需注意）  
 

        package mugbya.main;
        
        import mugbya.timer.MyTimer;
        import mugbya.timer.TimerActionAdpadter;
        import mugbya.timer.TimerActionListener;
        import mugbya.timer.TimerEventArg;
        
        /**
         * @author mugbya
         * 
         * @version 2014年1月22日
         * 
         */
        public class Test implements TimerActionListener {
            public static void main(String[] args) {
        
                MyTimer timer = new MyTimer();
                
                /**
                 * 用监听器指派需要处理的事情 1
                 */
               timer.addActionListner(new TimerActionAdpadter() {
                   @Override  
                   public void handleEvent(MyTimer sender, TimerEventArg arg) {
                       System.out.println("mm");
                    }
                });
                /**
                 * 用接口回调处理事情 2
                 */
                timer.addActionListner(new TimerActionListener() {		
                   @Override
                  public void handleEvent(MyTimer sender, TimerEventArg arg) {
                        System.out.println("GG");
                    }
                });
                Test tst = new Test();
                timer.addActionListner(tst);
                timer.start();
            }
        
            @Override // 3
            public void handleEvent(MyTimer Sender, TimerEventArg arg) {
                System.out.println("-------");
            }
        }


在最后的Test代码中，写下了3中实现方式。
