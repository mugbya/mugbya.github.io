---
layout: post
title: 有关TreeSet的问题
thread: 15
categories: 记录
tags: java
---

 - TreeSet集合继承于AbstractSet类,实现了 Set 接口，其实际基于 TreeMap 的 NavigableSet 实现的。

- TreeSet 存放元素是有序的： 默认使用自然排序（升序），或者根据提供的 比较器(Comparator) 进行排序.

- 实现Set集合都是不存放相同元素（HastSet 与 TreeSet 元素相同指的都不一样）这里简单讨论TreeSet

  *  TreeSet 根据 equals 或是 实现的 比较器 判定是否相等，并且 比较器 是优先于equals的。API文档做了如下说明：
  
> Set 接口是按照 equals 操作定义的，但 TreeSet 实例使用它的 compareTo（或 compare）方法对所有元素进行比较，因此从 set 的观点来看，此方法认为相等的两个元素就是相等的。即使 set 的顺序与 equals 不一致，其行为也是 定义良好的；它只是违背了 Set 接口的常规协定。

下面我们演示下：

	import java.util.TreeSet;

	public class TreeSetDemo implements Comparable{
	
		private String name;
	
		public TreeSetDemo(String name) {
			this.name = name;
		}	
        /*
         * 实现比较器
         */
        public int compareTo(Object o) {		
            return 0;   //请注意这里的返回0
        }
        /*
         * 重写toString方法，便于我们观察
         */
        public String toString() {
            return "(name=" + name + ")";
        }	
        public static void main(String[] args) {
            TreeSetDemo one = new TreeSetDemo("Steven");
            TreeSetDemo two = new TreeSetDemo("Steven");	
            
            TreeSet<TreeSetDemo> set = new TreeSet<TreeSetDemo> ();
            set.add(one);
            set.add(two);
            System.out.println(set);
        }
    }

当我们 compareTo 方法中返回 0 时，则表明它们相等 ，TreeSet集合就不再接受相同元素的值了，而上面我们的测试结果也是 <code>[(name=Steven)]</code>;而当我们写下 compareTo 方法中的返回值时（只要不等于0），那么输出结果就为<code>[(name=Steven), (name=Steven)]</code> 
所以我们应该知道，比较器对于 TreeSet 存储元素是很重要的
 
  于 2014 年 1 月 1 号 完结
